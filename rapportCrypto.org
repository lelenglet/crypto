#+TITLE: Rapport sécurité : crypter et décrypter
#+HTML_HEAD: <link rel='stylesheet' type='text/css' href='style.css'/>

Rapport de [[https://perso.isima.fr/~lelenglet][Léa Lenglet]] et [[https://perso.isima.fr/~mavillatte3][Mathilde Villatte]] | Prep'ISIMA \\
[[./images/logos.jpeg]]

* Introduction
Ce travail consiste à mettre en évidence la facilité avec laquelle il est possible de
casser une clé par substitution. Nous utiliserons l'alphabet 'A', 'B', 'C', ..., 'Z', ' '
(caractère d'espacement). \\
Notre travail devra comprendre les fonctions suivantes:
- Une fonction *permutation*, qui génère une chaîne contenant une permutation aléatoire de
l'alphabet
- Une fonction *chiffrement*, qui saisit un message et une clef de chiffrement et renvoie 
le message chiffré par substitution
- Une fonction *déchiffrement*, qui prend un message chiffré ainsi que sa clef de 
chiffrement et renvoie le message déchiffré
- Une fonction *nettoyage*, qui prend un texte et le transforme afin qu'il ne comporte plus
que les caractères de l'alphabet
- Une fonction *fréquence*, qui reçoit un texte ne comprenant que des caractères de 
l'alphabet et renvoie les fréquences d'apparition de chacun des caractères de l'alphabet 
dans ce texte. On appelle cette sortie la 'table des fréquences' du fichier
- Une fonction *décryptage*, qui prend en entrée un message chiffré et renvoie le message 
original

* Résolution
** Méthodologie
** Principe de la résolution
*** Permutation
Nous commençons par la fonction /Permutation/, prenant comme argument un tableau de
caractère *sortie*, nous permettant de générer une clef de chiffrement aléatoire à l'aide 
de l'alphabet, que nous stockerons dans ce tableauy. \\
Pour cela, nous créons une variable *sortie*, dans laquelle nous copions notre alphabet. 
Pour chaque lettre de notre alphabet, nous prenons un nombre aléatoire grâce à la fonction
/random/, puis nous inversons le caractère à l'indice random et le caractère à l'indice i.
Nous devons utiliser une variable temporaire *temp* dans laquelle nous stockons le 
caractère à l'indice i, puis affectons le caractère à l'indice random à l'indice i. Nous 
affectons pour finir le caractère *temp* à l'indice random.

#+NAME: permutation
#+BEGIN_SRC C :results none
void Permutation(char sortie[]){
    int i ; // compteur
    int random;
    char alphabet[N];
    strcpy(alphabet,"ABCDEFGHIJKLMNOPQRSTUVWXYZ ");
    strcpy(sortie,alphabet);//alphabet de départ copié dans la sortie
    char temp;

    for (i=strlen(sortie)-2; i>1; i--){ // longueur-2 pour exclure la dernière case contenant '/0' de la permutation
        random = rand () % i;
        temp= sortie[i];
        sortie[i]=sortie[random];
        sortie[random]=temp;
    }
}
#+END_SRC

*** Chiffrement
Afin de réaliser notre fonction /chiffrement/, nous créons une fonction /indice_in_alpha/,
qui prend comme argument un caractère et renvoie son indice dans l'alphabet. \\

#+NAME: indice_in_alpha
#+BEGIN_SRC C :results none
int indice_in_alpha(char carac){
    int indice=0;
    char alphabet[N];
    strcpy(alphabet,"ABCDEFGHIJKLMNOPQRSTUVWXYZ ");
    while (alphabet[indice]!=carac){
        indice++;
    }
    return indice;
    //fonction permettant de trouver l'indice du carac dans l'alaphabet
    //retourne indice
}
#+END_SRC

Nous passons ensuite à la fonction /chiffrement/, qui prend comme arguments un tableau de
caractère *sortie*, que nous allons remplir de notre texte, contenu dans un tableau de 
caractère *text*, chiffré avec la clef contenue dans un tableau de caractère *clef*. \\
Nous parcourons notre texte jusqu'à arriver à '\0', qui marque la fin de ce dernier. 
Pour chaque caractère de notre texte, nous affectons à notre sortie le caractère chiffré
correspondant. Nous retrouvons donc notre texte chiffré dans le tableau de caractère 
*sortie*.

#+NAME: chiffrement
#+BEGIN_SRC C
void Chiffrement(char sortie[], char text[], char clef[]){
    int i =0;
    int indice;
    while (text[i]!='\0'){
        indice=indice_in_alpha(text[i]);
        sortie[i]=clef[indice];
        i++;
    }
    sortie[i]='\0';
    // on parcourt le texte avec une boucle tant que text[i]!='\0'
    // on prends le caractère et on le remplace avec le caractère associé dans la clef de chiffrement
    // le message chiffré est stocké par effet de bord dans la variable sortie
}
#+END_SRC

*** Déchiffrement
Comme pour notre fonction /chiffrement/, nous créons une fonction /indice_in_clef/ pour 
notre fonction /dechiffrement/, qui prend comme argument un tableau de caractère contenant
la clef de chiffrement, ainsi qu'un caractère, et qui retourne la position de ce caractère
dans la clef.

#+NAME: indice_in_clef
#+BEGIN_SRC C :results none
int indice_in_clef(char clef[],char carac){
    int indice=0;
    while (clef[indice]!=carac){
        indice++;
    }
    return indice;
    //fonction permettant de trouver l'indice du carac dans l'alaphabet
    //retourne indice
}
#+END_SRC

Nous passons donc à la fonction /edchiffrement/, qui prend comme arguments un tableau de
caractère *sortie*, que nous allons remplir de notre texte, contenu dans un tableau de 
caractère *text*, déchiffré avec la clef contenue dans un tableau de caractère *clef*. \\
Nous affectons à une variable *alphabet* l'alphabet non permuté, puis nous parcourons 
notre texte jusqu'à arriver à '\0', qui marque la fin de ce dernier. 
Pour chaque caractère de notre texte, nous affectons à notre sortie le caractère déchiffré
correspondant. Nous retrouvons donc notre texte déchiffré dans le tableau de caractère 
*sortie*.

#+NAME: dechiffrement
#+BEGIN_SRC C :results none
void Dechiffrement(char sortie[], char text[], char clef[]){
    int i =0;
    int indice;
    char alphabet[N];
    strcpy(alphabet,"ABCDEFGHIJKLMNOPQRSTUVWXYZ ");

    while (text[i]!='\0'){
        indice=indice_in_clef(clef,text[i]);
        sortie[i]=alphabet[indice];
        i++;
    }
    sortie[i]='\0';
}

#+END_SRC

*** Nettoyage
Nous créons une fonction /Changement_carac/, qui prend pour argument un caractère et qui 
retourne la chaîne de caractère modifiée comme suit:
- si le caractère est une lettre en minuscule ou accentuée, retourne la lettre en majuscule
non accentuée
- si le caractère est un caractère autre qu'une lettre ou un espace, retourne un point '.'

#+NAME: changement_carac
#+BEGIN_SRC C :results none
char Changement_carac(char carac){
    /* Retourne :
     * '.' pour tous les éléments ne devant pas apparitre dans la chaine "propre"
     * 'Majuscule' pour tous les éléments minuscules et accentuées
     * ' ' pour tous les espaces */
    char sortie='.'; // le cas ou il ne trouve pas des exceptions
    if ((carac<'a' || carac>'z')&& (carac<'A' ||carac>'Z') && carac!=' '){
        if (carac==-96){
                sortie='A'; //remplacer à
        }
        else if (carac>=-88 && carac<=-85){
            sortie='E'; //remplacer é è ê ë
        }
        else if (carac==-89){
            sortie='C'; // remplacer ç
        }
        else if (carac==-71){ // remplacer ù
            sortie='U';
        }
        else if (carac==-76){//remplacer ô
            sortie='O';
        }
        else if (carac==':' || carac=='!' || carac=='?' || carac==',' || carac=='.' || carac=='\'' || carac=='-'){
            sortie='.';
        }}
    else {
        if(carac>='a' && carac<='z'){
            sortie=carac+('A'-'a');
        }
        else {
            sortie=carac;
        }
    }
    return sortie;
}
#+END_SRC

Notre fonction /nettoyage/ prend comme arguments un tableau de caractères *sortie*, que l'on
va remplir à l'aide de notre tableau de caractères *text* nettoyé. \\
Pour se faire, nous parcourons notre *text* jusqu'à parvenir à '\0', qui représente la fin
de notre tableau. Nous faisons un appel à notre fonction /Changement_carac/ sur chaque
caractère de notre tableau, et nous affectons à une variable temporaire *temp* le résultat.
Nous remplissons notre tableau *sortie* comme suit : nous ajoutons la variable *temp* 
seulement si elle est différente d'un point '.'. Ainsi nous nous retrouvons avec notre 
texte ne contenant que les lettres de l'alphabet et les espaces.

#+NAME: nettoyage
#+BEGIN_SRC C :results none
void  Nettoyage(char sortie[],char text[]){
    int i=0 ,j=0;
    char temp;
    while (text[i]!='\0'){
        temp=Changement_carac(text[i]);
        if (temp!='.'){
            sortie[j]=temp;
            j++;
        }
        i++;
    }
    sortie[j]='\0'; //je rajoute '\0' pour éviter l'apparition de caractère non désiré
}
#+END_SRC

*** Occurence
Nous créons une fonction /occurence/, qui prend comme arguments un tableau de flottants
ainsi qu'un tableau de caractères. \\
Notre fonction parcours notre texte (qui doit être préalablement nettoyé), et qui, pour 
chaque lettre, regarde l'indice de cette lettre dans l'alphabet grâce à notre fonction 
/indice_in_alpha/, et ajoute 1 dans notre tableau d'entier à l'indice de la lettre, nous
donnant le nombre d'apparition de cette lettre dans le texte. \\
Nous parcourons notre tableau de flottans et divisons chaque nombre par le nombre total
de lettre dans notre texte, et nous obtenons ainsi la fréquence d'appartion de chacune des
lettres de notre texte.

#+NAME: occurence
#+BEGIN_SRC C :results none
void occurence(float tab[],char text[]){
    int i=0;
    int nb_carac=1;
    int indice;
    while (text[i]!='\0'){
        indice=indice_in_alpha(text[i]);

        tab[indice]+=1;
        nb_carac++;
        i++;
    }
    for (i=0;i<N-1;i++){
        tab[i]=tab[i]/nb_carac;
    }
}
#+END_SRC
** Code commenté
#+BEGIN_SRC C :export both :noweb yes :results output
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#define N 28 // longueur pour l'alphabet

////// FONCTION 1 : PERMUTATION ////
<<permutation>>

////// FONCTION 2 : CHIFFREMENT ////
<<indice_in_alpha>>

<<chiffrement>>

//// FONCTION 3 : DECHIFFREMENT ////
<<indice_in_clef>>

<<dechiffrement>>

//// FONCTION 4 : NETTOYAGE ////
<<changement_carac>>

#+END_SRC 

* Résultats obtenus

