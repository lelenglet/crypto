#+TITLE: Rapport sécurité : crypter et décrypter
#+OPTIONS: author:Lenglet Léa / Villatte Mathilde date:nil
#+HTML_HEAD: <link rel='stylesheet' type='text/css' href='style.css'/>

Rapport de [[https://perso.isima.fr/~lelenglet][Léa Lenglet]] et [[https://perso.isima.fr/~mavillatte3][Mathilde Villatte]] | Prep'ISIMA \\
#+attr_html: :width 500px
[[https://cdn.uca.fr/images/logos/ISIMA-logo-carre.png]]

* Introduction

Ce travail consiste à mettre en évidence la facilité avec laquelle il est possible de
casser une clé par substitution. Nous utiliserons l'alphabet 'A', 'B', 'C', ..., 'Z', ' '
(caractère d'espacement). \\
Notre travail devra comprendre les fonctions suivantes:
- Une fonction *permutation*, qui génère une chaîne contenant une permutation aléatoire de
l'alphabet
- Une fonction *chiffrement*, qui saisit un message et une clef de chiffrement et renvoie 
le message chiffré par substitution
- Une fonction *déchiffrement*, qui prend un message chiffré ainsi que sa clef de 
chiffrement et renvoie le message déchiffré
- Une fonction *nettoyage*, qui prend un texte et le transforme afin qu'il ne comporte plus
que les caractères de l'alphabet
- Une fonction *fréquence*, qui reçoit un texte ne comprenant que des caractères de 
l'alphabet et renvoie les fréquences d'apparition de chacun des caractères de l'alphabet 
dans ce texte. On appelle cette sortie la 'table des fréquences' du fichier
- Une fonction *décryptage*, qui prend en entrée un message chiffré et renvoie le message 
original

#+attr_html: :width 350px
[[https://www.frenchweb.fr/wp-content/uploads/2016/09/code-secret.jpg]]


* Résolution
** Méthodologie
Afin d'organiser notre travail efficacement, nous avons répartis les tâches de la manière suivante :
+ Les 5 premières fonctions du projet ont été traité par Léa en 15 heures environ.
+ La dernière fonction décryptage est traitée par Mathilde qui s'est également occupée d'une grande partie du rapport en orgmode.
+ La partie test a été traité par Léa.

** Principe de la résolution
Dans l'ensemble des fonctions de la solution proposée, nous passons en argument la sortie afin qu'elle soit modifiée par effet de bord. L'alphabet "ABCDEFGHIJKLMNOPQRSTUVWXYZ " est celui choisi par défaut, on prend donc la liberté de réaffecter manuellement la variable ~alphabet~ pour éviter la surcharge dans la signature de certaines fonctions.
*** Permutation
Nous commençons par implémenter la fonction /Permutation/, prenant comme argument un tableau de
caractère ~sortie~, nous permettant de générer une clef de chiffrement aléatoire à l'aide
de l'alphabet, que nous stockerons dans ce tableau. \\
Pour cela, nous copions notre alphabet dans le tableau ~sortie~.
Pour chaque lettre de notre alphabet, nous prenons un nombre aléatoire grâce à la fonction
/random/ et à la commande ~srand(time(NULL))~ dans le main de notre programme, puis nous inversons le caractère à l'indice random et le caractère à l'indice i.
Nous devons utiliser une variable temporaire *temp* afin de pouvoir stocker les différentes valeurs du tableau sans perte de données durant la permutation des valeurs.

#+NAME: permutation
#+BEGIN_SRC C :results none
void Permutation(char sortie[]){
    int i ; // compteur
    int random;
    char alphabet[N];
    strcpy(alphabet,"ABCDEFGHIJKLMNOPQRSTUVWXYZ ");
    strcpy(sortie,alphabet);//alphabet de départ copié dans la sortie
    char temp;

    for (i=strlen(sortie)-1; i>1; i--){ // longueur-1 pour exclure la dernière case contenant '/0' de la permutation
        random = rand () % i;
        temp= sortie[i];
        sortie[i]=sortie[random];
        sortie[random]=temp;
    }
}
#+END_SRC

*** Chiffrement
Afin de réaliser notre fonction /chiffrement/, nous créons une fonction ~indice_in_alpha~,
qui prend comme argument un caractère et renvoie son indice dans l'alphabet. \\

#+NAME: indice_in_alpha
#+BEGIN_SRC C :results none
int indice_in_alpha(char carac){
    int indice=0;
    char alphabet[N];
    strcpy(alphabet,"ABCDEFGHIJKLMNOPQRSTUVWXYZ ");
    while (alphabet[indice]!=carac){
        indice++;
    }
    return indice;
    //fonction permettant de trouver l'indice du carac dans l'alaphabet
    //retourne indice
}
#+END_SRC

La fonction /chiffrement/ ,quant à elle , prend comme arguments un tableau de
caractère ~sortie~, que nous allons remplir à partir de notre texte, contenu dans un tableau de
caractère ~text~, chiffré avec la clef contenue dans un tableau de caractère ~clef~. \\
Nous parcourons notre texte jusqu'à arriver à '\0', qui marque la fin de ce dernier. 
Pour chaque caractère de notre texte, nous affectons à notre sortie le caractère chiffré avec ~indice_in_alpha~.

#+NAME: chiffrement
#+BEGIN_SRC C
void Chiffrement(char sortie[], char text[], char clef[]){
    int i =0;
    int indice;
    while (text[i]!='\0'){
        indice=indice_in_alpha(text[i]);
        sortie[i]=clef[indice];
        i++;
    }
    sortie[i]='\0';
    // on parcourt le texte avec une boucle tant que text[i]!='\0'
    // on prends le caractère et on le remplace avec le caractère associé dans la clef de chiffrement
    // le message chiffré est stocké par effet de bord dans la variable sortie
}
#+END_SRC

*** Déchiffrement
Comme pour notre fonction /chiffrement/, nous créons une fonction ~indice_in_clef~ pour
notre fonction /dechiffrement/, qui prend comme argument un tableau de caractère contenant
la clef de chiffrement, ainsi qu'un caractère, et qui retourne la position de ce caractère
dans la clef.

#+NAME: indice_in_clef
#+BEGIN_SRC C :results none
int indice_in_clef(char clef[],char carac){
    int indice=0;
    while (clef[indice]!=carac){
        indice++;
    }
    return indice;
    //fonction permettant de trouver l'indice du carac dans l'alaphabet
    //retourne indice
}
#+END_SRC

La fonction /dechiffrement/, qui prend comme arguments un tableau de
caractère ~sortie~, que nous allons remplir avec notre texte, contenu dans un tableau de
caractère ~text~, déchiffré avec la clef contenue dans un tableau de caractère ~clef~. \\
Nous affectons à une variable ~alphabet~ l'alphabet non permuté, puis nous parcourons
notre texte jusqu'à arriver à '\0', qui marque la fin de ce dernier. 
Pour chaque caractère de notre texte, nous affectons à notre sortie le caractère déchiffré
correspondant. Nous retrouvons donc notre texte déchiffré dans le tableau de caractère 
~sortie~.

#+NAME: dechiffrement
#+BEGIN_SRC C :results none
void Dechiffrement(char sortie[], char text[], char clef[]){
    int i =0;
    int indice;
    char alphabet[N];
    strcpy(alphabet,"ABCDEFGHIJKLMNOPQRSTUVWXYZ ");

    while (text[i]!='\0'){
        indice=indice_in_clef(clef,text[i]);
        sortie[i]=alphabet[indice];
        i++;
    }
    sortie[i]='\0';
}

#+END_SRC

*** Nettoyage
Nous créons une fonction ~Changement_carac~, qui prend pour argument un caractère et qui
retourne le caractère modifié comme suit:
- si le caractère est une lettre en minuscule ou accentuée, retourne la lettre en majuscule
non accentuée.
- si le caractère est un caractère autre qu'une lettre ou un espace, retourne un point '.'.

#+NAME: changement_carac
#+BEGIN_SRC C :results none
char Changement_carac(char carac){
    /* Retourne :
     * '.' pour tous les éléments ne devant pas apparitre dans la chaine "propre"
     * 'Majuscule' pour tous les éléments minuscules et accentuées
     * ' ' pour tous les espaces */
    char sortie='.'; // le cas ou il ne trouve pas des exceptions
    if ((carac<'a' || carac>'z')&& (carac<'A' ||carac>'Z') && carac!=' '){
        if (carac==-96 || carac==-94 || carac==-92 ){
                sortie='A'; //remplacer à â ä
        }
        else if (carac>=-88 && carac<=-85){
            sortie='E'; //remplacer é è ê ë
        }
        else if (carac==-89){
            sortie='C'; // remplacer ç
        }
        else if (carac==-71 || carac ==-69 || carac==-68){ // remplacer ù û ü
            sortie='U';
        }
        else if (carac==-76 || carac==-74){//remplacer ô ö
            sortie='O';
        }
        else if (carac==-82 || carac==-81){//remplacer î ï
            sortie='I';
        }
        else if (carac==':' || carac=='!' || carac=='?' || carac==',' || carac=='.' || carac=='\'' || carac=='-'){
            sortie='.';
        }}
    else {
        if(carac>='a' && carac<='z'){
            sortie=carac+('A'-'a');
        }
        else {
            sortie=carac;
        }
    }
    return sortie;
}
#+END_SRC

Notre fonction /nettoyage/ prend comme arguments un tableau de caractères ~sortie~, que l'on
va remplir à l'aide de notre tableau de caractères ~text~ nettoyé. \\
Pour se faire, nous parcourons notre chaine ~text~ jusqu'à parvenir à '\0'.
Nous faisons un appel à notre fonction ~Changement_carac~ pour chaque
caractère de notre tableau, et nous affectons à une variable temporaire ~temp~ le résultat.
Nous remplissons notre tableau ~sortie~ comme suit : nous ajoutons la variable ~temp~
seulement si elle est différente du caractère '.'. Ainsi nous nous retrouvons avec notre
texte ne contenant que les lettres de l'alphabet et les espaces.

#+NAME: nettoyage
#+BEGIN_SRC C :results none
void  Nettoyage(char sortie[],char text[]){
    int i=0 ,j=0;
    char temp;
    while (text[i]!='\0'){
        temp=Changement_carac(text[i]);
        if (temp!='.'){
            sortie[j]=temp;
            j++;
        }
        i++;
    }
    sortie[j]='\0'; //je rajoute '\0' pour éviter l'apparition de caractère non désiré
}
#+END_SRC

Problème survenu lors de l’implémentation:

Les caractères accentués sont représentés par deux caractères dans une chaine au lieu d'un seul.
Lors de plusieurs tests sur différents caractères de ce type, nous nous sommes rendus compte que la valeur du premier caractère est le même pour tous les caractères accentués tandis que le second caractère est représenté par un entier négatif distinct. Pour empêcher l'ajout d'un caractère supplémentaire indésirable dans la chaine de sortie nous avons décider de choisir le caractère '.' comme valeur à ignorer.


*** Occurence
Nous créons une fonction /occurence/, qui prend comme arguments un tableau de flottants
ainsi qu'un tableau de caractères. \\
Notre fonction parcours notre texte (qui doit être préalablement nettoyé), et qui, pour 
chaque lettre, regarde l'indice de cette lettre dans l'alphabet grâce à notre fonction 
/indice_in_alpha/, et ajoute 1 dans notre tableau d'entier à l'indice de la lettre, nous
donnant le nombre d'apparition de cette lettre dans le texte. \\
Nous parcourons notre tableau de flottans et divisons chaque nombre par le nombre total
de lettre dans notre texte, et nous obtenons ainsi la fréquence d'appartion de chacune des
lettres de notre texte.

#+NAME: occurence
#+BEGIN_SRC C :results none
void occurence(float tab[],char text[]){
    int i=0;
    int nb_carac=1;
    int indice;
    while (text[i]!='\0'){
        indice=indice_in_alpha(text[i]);
        tab[indice]+=1;
        nb_carac++;
        i++;
    }
    for (i=0;i<N-1;i++){
        tab[i]=tab[i]/nb_carac;
    }
}
#+END_SRC


** Code commenté
#+BEGIN_SRC C :export both :noweb yes :results output
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#define N 28 // longueur pour l'alphabet

////// FONCTION 1 : PERMUTATION ////
<<permutation>>

////// FONCTION 2 : CHIFFREMENT ////
<<indice_in_alpha>>

<<chiffrement>>

//// FONCTION 3 : DECHIFFREMENT ////
<<indice_in_clef>>

<<dechiffrement>>

//// FONCTION 4 : NETTOYAGE ////
<<changement_carac>>
<<nettoyage>>

//// FONCTION 5 : OCCURENCE ////
<<occurence>>


int main(){
    srand(time(NULL));
    int i;
    char alphabet[N];
    strcpy(alphabet, "ABCDEFGHIJKLMNOPQRSTUVWXYZ ");
    printf("------- ALPHABET -------\n|%s|\n\n",alphabet);

    //permutation
    char permutation[N];
    Permutation(permutation);
    printf("------- CLEF DE PERMUTATION -------\n");
    printf("%s\n\n",permutation);

    //nettoyage
    char text[]="Peut-être l’immobilité des choses autour de nous leur est-elle imposée par notre certitude que ce sont elles et non pas d’autres, par l’immobilité de notre pensée en face d’elles. Toujours est-il que, quand je me réveillais ainsi, mon esprit s’agitant pour chercher, sans y réussir, à savoir où j’étais, tout tournait autour de moi dans l’obscurité, les choses, les pays, les années. Mon corps, trop engourdi pour remuer, cherchait, d’après la forme de sa fatigue, à repérer la position de ses membres pour en induire la direction du mur, la place des meubles, pour reconstruire et pour nommer la demeure où il se trouvait. Sa mémoire, la mémoire de ses côtes, de ses genoux, de ses épaules, lui présentait successivement plusieurs des chambres où il avait dormi, tandis qu’autour de lui les murs invisibles, changeant de place selon la forme de la pièce imaginée, tourbillonnaient dans les ténèbres. Et avant même que ma pensée, qui hésitait au seuil des temps et des formes, eût identifié le logis en rapprochant les circonstances, lui, – mon corps, – se rappelait pour chacun le genre du lit, la place des portes, la prise de jour des fenêtres, l’existence d’un couloir, avec la pensée que j’avais en m’y endormant et que je retrouvais au réveil. Mon côté ankylosé, cherchant à deviner son orientation, s’imaginait, par exemple, allongé face au mur dans un grand lit à baldaquin et aussitôt je me disais : Tiens, j’ai fini par m’endormir quoique maman ne soit pas venue me dire bonsoir , j’étais à la campagne chez mon grand-père";
    char texte_propre[strlen(text)];
    Nettoyage(texte_propre,text);
    printf("------- TEXTE NETTOYE -------\n");
    printf("%s\n",texte_propre);
    printf("------- FIN ------\n\n");


    //ocurrence
    float table_des_frequences[N-1]={0}; //j'ai mis N-1 pour que le tableau soit de la taille de l'alphabet excepté '\0'
    occurence(table_des_frequences,texte_propre);
    printf("------- TABLE DES FREQUENCES --------\n");
    for (i=0;i<N-1;i++){
    printf("%c = %f | ",alphabet[i],table_des_frequences[i]);
    }
    printf("\n\n");

    //chiffrement
    char sortie_chiffree[strlen(texte_propre)];
    Chiffrement(sortie_chiffree,texte_propre,permutation);
    printf("------- TEXTE CHIFFREE -------\n");
    printf("%s\n",sortie_chiffree);
    printf("------- FIN ------\n\n");

    //dechiffrement
    char sortie_dechiffree[strlen(texte_propre)];
    Dechiffrement(sortie_dechiffree,sortie_chiffree,permutation);
    printf("------- TEXTE DECHIFFREE PAR FONCTION 4 -------\n");
    printf("%s\n",sortie_dechiffree);
    printf("------- FIN ------\n\n");


    //decryptage
    //char sortie_dechiffree[strlen(texte_propre)];
    //Decryptage(sortie_dechiffree, sortie_chiffree);
    //printf("------- TEXTE DECHIFFREE -------\n");
    //printf("%s\n",sortie_dechiffree);
    //printf("------- FIN -------\n");

    return 0;
}


#+END_SRC 

#+RESULTS:
#+begin_example
------- ALPHABET -------
|ABCDEFGHIJKLMNOPQRSTUVWXYZ |

------- CLEF DE PERMUTATION -------
RKGQFMPXDT SOHCYEZWALNBJUVI

------- TEXTE NETTOYE -------
PEUTETRE LIMMOBILITE DES CHOSES AUTOUR DE NOUS LEUR ESTELLE IMPOSEE PAR NOTRE CERTITUDE QUE CE SONT ELLES ET NON PAS DAUTRES PAR LIMMOBILITE DE NOTRE PENSEE EN FACE DELLES TOUJOURS ESTIL QUE QUAND JE ME REVEILLAIS AINSI MON ESPRIT SAGITANT POUR CHERCHER SANS Y REUSSIR A SAVOIR OU JETAIS TOUT TOURNAIT AUTOUR DE MOI DANS LOBSCURITE LES CHOSES LES PAYS LES ANNEES MON CORPS TROP ENGOURDI POUR REMUER CHERCHAIT DAPRES LA FORME DE SA FATIGUE A REPERER LA POSITION DE SES MEMBRES POUR EN INDUIRE LA DIRECTION DU MUR LA PLACE DES MEUBLES POUR RECONSTRUIRE ET POUR NOMMER LA DEMEURE OU IL SE TROUVAIT SA MEMOIRE LA MEMOIRE DE SES COTES DE SES GENOUX DE SES EPAULES LUI PRESENTAIT SUCCESSIVEMENT PLUSIEURS DES CHAMBRES OU IL AVAIT DORMI TANDIS QUAUTOUR DE LUI LES MURS INVISIBLES CHANGEANT DE PLACE SELON LA FORME DE LA PIECE IMAGINEE TOURBILLONNAIENT DANS LES TENEBRES ET AVANT MEME QUE MA PENSEE QUI HESITAIT AU SEUIL DES TEMPS ET DES FORMES EUT IDENTIFIE LE LOGIS EN RAPPROCHANT LES CIRCONSTANCES LUI  MON CORPS  SE RAPPELAIT POUR CHACUN LE GENRE DU LIT LA PLACE DES PORTES LA PRISE DE JOUR DES FENETRES LEXISTENCE DUN COULOIR AVEC LA PENSEE QUE JAVAIS EN MY ENDORMANT ET QUE JE RETROUVAIS AU REVEIL MON COTE ANKYLOSE CHERCHANT A DEVINER SON ORIENTATION SIMAGINAIT PAR EXEMPLE ALLONGE FACE AU MUR DANS UN GRAND LIT A BALDAQUIN ET AUSSITOT JE ME DISAIS  TIENS JAI FINI PAR MENDORMIR QUOIQUE MAMAN NE SOIT PAS VENUE ME DIRE BONSOIR  JETAIS A LA CAMPAGNE CHEZ MON GRANDPERE
------- FIN ------

------- TABLE DES FREQUENCES --------
A = 0.066803 | B = 0.007498 | C = 0.025903 | D = 0.030675 | E = 0.135651 | F = 0.006135 | G = 0.008862 | H = 0.009543 | I = 0.062031 | J = 0.006135 | K = 0.000682 | L = 0.042945 | M = 0.032720 | N = 0.053851 | O = 0.051806 | P = 0.028630 | Q = 0.007498 | R = 0.059305 | S = 0.071575 | T = 0.051125 | U = 0.049080 | V = 0.008862 | W = 0.000000 | X = 0.002045 | Y = 0.002727 | Z = 0.000682 |   = 0.176551 |

------- TEXTE CHIFFREE -------
YFLAFAZFISDOOCKDSDAFIQFWIGXCWFWIRLACLZIQFIHCLWISFLZIFWAFSSFIDOYCWFFIYRZIHCAZFIGFZADALQFIELFIGFIWCHAIFSSFWIFAIHCHIYRWIQRLAZFWIYRZISDOOCKDSDAFIQFIHCAZFIYFHWFFIFHIMRGFIQFSSFWIACLTCLZWIFWADSIELFIELRHQITFIOFIZFNFDSSRDWIRDHWDIOCHIFWYZDAIWRPDARHAIYCLZIGXFZGXFZIWRHWIUIZFLWWDZIRIWRNCDZICLITFARDWIACLAIACLZHRDAIRLACLZIQFIOCDIQRHWISCKWGLZDAFISFWIGXCWFWISFWIYRUWISFWIRHHFFWIOCHIGCZYWIAZCYIFHPCLZQDIYCLZIZFOLFZIGXFZGXRDAIQRYZFWISRIMCZOFIQFIWRIMRADPLFIRIZFYFZFZISRIYCWDADCHIQFIWFWIOFOKZFWIYCLZIFHIDHQLDZFISRIQDZFGADCHIQLIOLZISRIYSRGFIQFWIOFLKSFWIYCLZIZFGCHWAZLDZFIFAIYCLZIHCOOFZISRIQFOFLZFICLIDSIWFIAZCLNRDAIWRIOFOCDZFISRIOFOCDZFIQFIWFWIGCAFWIQFIWFWIPFHCLJIQFIWFWIFYRLSFWISLDIYZFWFHARDAIWLGGFWWDNFOFHAIYSLWDFLZWIQFWIGXROKZFWICLIDSIRNRDAIQCZODIARHQDWIELRLACLZIQFISLDISFWIOLZWIDHNDWDKSFWIGXRHPFRHAIQFIYSRGFIWFSCHISRIMCZOFIQFISRIYDFGFIDORPDHFFIACLZKDSSCHHRDFHAIQRHWISFWIAFHFKZFWIFAIRNRHAIOFOFIELFIORIYFHWFFIELDIXFWDARDAIRLIWFLDSIQFWIAFOYWIFAIQFWIMCZOFWIFLAIDQFHADMDFISFISCPDWIFHIZRYYZCGXRHAISFWIGDZGCHWARHGFWISLDIIOCHIGCZYWIIWFIZRYYFSRDAIYCLZIGXRGLHISFIPFHZFIQLISDAISRIYSRGFIQFWIYCZAFWISRIYZDWFIQFITCLZIQFWIMFHFAZFWISFJDWAFHGFIQLHIGCLSCDZIRNFGISRIYFHWFFIELFITRNRDWIFHIOUIFHQCZORHAIFAIELFITFIZFAZCLNRDWIRLIZFNFDSIOCHIGCAFIRH USCWFIGXFZGXRHAIRIQFNDHFZIWCHICZDFHARADCHIWDORPDHRDAIYRZIFJFOYSFIRSSCHPFIMRGFIRLIOLZIQRHWILHIPZRHQISDAIRIKRSQRELDHIFAIRLWWDACAITFIOFIQDWRDWIIADFHWITRDIMDHDIYRZIOFHQCZODZIELCDELFIORORHIHFIWCDAIYRWINFHLFIOFIQDZFIKCHWCDZIITFARDWIRISRIGROYRPHFIGXFVIOCHIPZRHQYFZF
------- FIN ------

------- TEXTE DECHIFFREE PAR FONCTION 4 -------
PEUTETRE LIMMOBILITE DES CHOSES AUTOUR DE NOUS LEUR ESTELLE IMPOSEE PAR NOTRE CERTITUDE QUE CE SONT ELLES ET NON PAS DAUTRES PAR LIMMOBILITE DE NOTRE PENSEE EN FACE DELLES TOUJOURS ESTIL QUE QUAND JE ME REVEILLAIS AINSI MON ESPRIT SAGITANT POUR CHERCHER SANS Y REUSSIR A SAVOIR OU JETAIS TOUT TOURNAIT AUTOUR DE MOI DANS LOBSCURITE LES CHOSES LES PAYS LES ANNEES MON CORPS TROP ENGOURDI POUR REMUER CHERCHAIT DAPRES LA FORME DE SA FATIGUE A REPERER LA POSITION DE SES MEMBRES POUR EN INDUIRE LA DIRECTION DU MUR LA PLACE DES MEUBLES POUR RECONSTRUIRE ET POUR NOMMER LA DEMEURE OU IL SE TROUVAIT SA MEMOIRE LA MEMOIRE DE SES COTES DE SES GENOUX DE SES EPAULES LUI PRESENTAIT SUCCESSIVEMENT PLUSIEURS DES CHAMBRES OU IL AVAIT DORMI TANDIS QUAUTOUR DE LUI LES MURS INVISIBLES CHANGEANT DE PLACE SELON LA FORME DE LA PIECE IMAGINEE TOURBILLONNAIENT DANS LES TENEBRES ET AVANT MEME QUE MA PENSEE QUI HESITAIT AU SEUIL DES TEMPS ET DES FORMES EUT IDENTIFIE LE LOGIS EN RAPPROCHANT LES CIRCONSTANCES LUI  MON CORPS  SE RAPPELAIT POUR CHACUN LE GENRE DU LIT LA PLACE DES PORTES LA PRISE DE JOUR DES FENETRES LEXISTENCE DUN COULOIR AVEC LA PENSEE QUE JAVAIS EN MY ENDORMANT ET QUE JE RETROUVAIS AU REVEIL MON COTE ANKYLOSE CHERCHANT A DEVINER SON ORIENTATION SIMAGINAIT PAR EXEMPLE ALLONGE FACE AU MUR DANS UN GRAND LIT A BALDAQUIN ET AUSSITOT JE ME DISAIS  TIENS JAI FINI PAR MENDORMIR QUOIQUE MAMAN NE SOIT PAS VENUE ME DIRE BONSOIR  JETAIS A LA CAMPAGNE CHEZ MON GRANDPERE
------- FIN ------

#+end_example


* Résultats obtenus
